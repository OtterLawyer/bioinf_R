# Сегодня мы поговрим о некоторых базовых статистиках, попробуем вычислить их
# и обсудим первые шаги в анализе данных

# Автор: Алексей Замалутдинов

#-------------------------------------------------------------------------

# Освежим в памяти основы работы с R
# Скрипты состоят из двух частей: исполняемой и комментариев
# Все комментарии начинаются с символа # 

It is the executable part # Выделите и нажмите Run
# если мы попробуем выполнить строку, будет ошибка

# Попробуйте теперь с этим
"It is the executable part"
'Hello world'
# Это работает и выдает текст в консоль

# Попробуем с числами
7+3
# Мы можем делать расчёты в консоли!
# Попробуйте с другими арифметическими операциями и объясните результат
# -
# *
# /
# %%
# %/%
# **
# ^
# Так что мы можем использовать R вместо калькулятора:)

#-------------------------------------------------------------------------

# Мы много всего посчитали, но результат выводился в консоль
# Давайте его сохраним

a <- 7+3 # эта стрелочка (<-) означает, что мы присвоили значение переменной а. Вы можете использовать Alt+- , чтобы нарисовать её.
a # можно посмотреть, что внутри а

b <- 9
a + b

#-------------------------------------------------------------------------

# Мы уже поработали с числами и текстом, давайте обсудим другие типы данных
# 4 основных типа данных в R

1      # integer - целые числа, занимают меньше места
1.01   # numeric - все числа
"Text" # character - текст
TRUE   # logical - хранит TRUE или FALSE


# Довольно очевидно, зачем нужны первые 3 и как их сохранить
# Попробуем сделать так

1>2      # FALSE, мы уверены, что это logical?
str(1>2) # специальная команда для проверка типа данных
# Попробуйте использовать её с другими значениями. Напечатайте ваш код ниже

#-------------------------------------------------------------------------

# Мы встретились с новой штукой типа str(1>2). Они называются функциями.
# Функции могут комбинировать несколько операций внутри себя и выдавать результат.
# Таким образом, str - это имя функции, а всё что идёт далее в скобках это её аргументы.
# Аргументы могут содержать входные данные и параметры, влиящие на работу функции
# Однако, некоторые из функций могут работать вообще без аргументов

getwd() # показывает путь до рабочей директории

#-------------------------------------------------------------------------

# Есть несколько способов организовать данные, когда мы работаем с несколькими числами.
# Базовый и простейший формат - векторы
a <- c(1,2,3)
b <- c(1,"2",3)
c <- c() # Давайте создадим вектор с logical, characters и numbers данными

# Векторы могут хранить значения одного типа: numeric, characters или logical
# Поэтому если мы добавляем данные другого типа, то они конвертируются

# Мы можем добавлять значения в вектора и соединять их
d <- c(a,5,a)
d

# Мы можем производить вычисления не только с одним значением, а со всем вектором сразу.

# Попробуйте вычисления с разными операторами
# +
# -
# *
# /
# %%
# %/%
# **
# ^

# Мы также можем производить базовые статистические операции, например:

min(d)    # минимальное значение
max(d)    # максимальное значение
range(d)  # минимальное и максимальное значение в новом векторе
mean(d)   # среднее
length(d) # количество элементов в векторе
sd(d)     # стандартное отклонение 
var(d)    # дисперсия
median(d) # медиана
IQR(d)    # межквартильный размах

# и даже сравнивать вектор с некоторым значением

j <- d>2
str(j)

# На основе этих функций давайте сделаем маленькое упражнение
# Мы будем использовать значения уровня озера Гурон из датасета LakeHuron 

?LakeHuron # вопросительный знак открывает страницу справки 
Lake <- as.vector(LakeHuron) # сохраним в новую переменную

# Рассчитайте разницу между наибольшим и наименьшим уровнем озера 
# и сохраните в переменную my_answer 

my_answer <-
  
print(paste("Разница в уровне озера",my_answer,"футов. Не так уж и много!"))

#-------------------------------------------------------------------------

# Хорошо, мы готовы начать работать с данными
# Мы можем использовать полный путь для выбора файлов, но это не всегда удобно и визуально нагружает код
# Эта небольшая комбинация позволяет определить где находится наш скрипт и установить рабочую директорию
main_dir <- dirname(rstudioapi::getSourceEditorContext()$path) 
main_dir
setwd(main_dir)

# Теперь мы можем загрузить наши данные и существует несколько способов сделать это:

# 1) Просто написать что-то типа read.csv()
manual_stats <- read.csv("manual_stats.csv")

# 2) Нажать кнопку import в правом верхнем углу

# 3) Загрузить файл по ссылке (read.csv() поддерживает URLs)

#-------------------------------------------------------------------------

# Посмотрим, что находится в нашем файле
str(manual_stats) # На самом деле это набор векторов!

# Попрактикуемся в вычислении базовых статистик вручную

# Среднее
mean(manual_stats$price)
# Даёт нам первую прикидку наиболее типичного значения в датасете
# Легко посчитать: сумма / число наблюдений
# Посчитаем среднюю price




# Медиана
# Просто середина сортированного списка
# Если число наблюдений чётное, то среднее из двух чисел должно быть использовано
median(manual_stats$price)

# Разумный вопрос, зачем нам нужна медиана, если у нас есть среднее?
# Давайте добавим ещё одно наблюдение к нашим данным
# 500 300 200
# Тогда price будет 30 55 25 43 60 500
# Снова посчитаем среднее и медиану
mean(c(30,55,25,43,60,500))
median(c(30,55,25,43,60,500))
#-------------------------------------------------------------------------

# Вернёмся к исходным данным
# Теперь мы примерно понимаем к расположены наши данные на числовой прямой, 
# но мы не знаем насколько они разннобразны.
# Начнём с наиболее простого - размаха
range(manual_stats$price)[2] - range(manual_stats$price)[1]

# Однако, он не даёт нам данных о распределении основной массы наших значений
# Также размах может быть смещён из-за выбросов

# Расчитаем другую метрику, интерквратильный размах (IQR).
# Идея - убрать выбросы из вычислений, чтобы получить более надёжную 
# оценку разброса, 
# где ~50% данных находится между 25 и 75 перцентилем.
# 0.25*n 0.75*n
IQR(manual_stats$price)

# Тем не менее это всё ещё просто разница между границами интервала, 
# нам хочется получить один более объективный параметр
# Одна из самых популярных это дисперсия
# Для его расчётов мы должны расчитать разницу между числами и средним, 
# найти квадрат этих различий и разделить на n-1
((25 - 42.6) ** 2 + (30-42.6) ** 2 + (43-42.6) ** 2 + (55-42.6) ** 2 + (60-42.6)** 2)/4
var(manual_stats$price)

# Однако, не так просто толковать это значение - потому что это квадрат (например, рубли в квадрате)
# Поэтому часто используют квадратный корень этого числа, стандартное отклонение.
var(manual_stats$price) ** 0.5
sd(manual_stats$price)
#-------------------------------------------------------------------------

# Хорошо, теперь у нас есть некоторое понимание наших данных, среднего и дисперсии
# Проанализируем связи между нашими переменными
# Мы все слышали о корреляции, но как она вычисляется?
# Cov(X,Y) / (std(x)*std(y))
# Мы вернёмся к корреляции немного позднее, остановимся на Cov(X,Y) 
# Это ковариация. И она расчитывается как sum((x-mean(x))*(y - mean(y)))/(n-1)
# Таким образом, мы считаем отклоняются ли наши величины в одну сторону или в разные.
# Если ковариация положительна, значит наши величины линейно зависимы, 
# когда одна переменная возрастает, другая тоже возрастает
# Если она равна 0, то линейная зависимость не может быть обнаружена

cov(manual_stats$fat, manual_stats$price)
((30-42.6) * (20-22.4) + (55-42.6) * (25-22.4) + (25-42.6) * (18-22.4) + (43-42.6) * (22-22.4) + (60-42.6) * (27-22.4)) / 4


# Проблема этой метрики - странные единицы измерения от -Inf до +Inf
# То есть "сила" связи зависит от размера наших величин


# Вот почему корреляция используется гораздо чаще. 
# Деление на std(x)*std(y) позволяет заключить ковариацию в интервал (-1 1) .
# Теперь мы знаем что такое ковариация и корреляция, давайте рассчитаем корреляцию

54.95 / (sd(manual_stats$price) * sd(manual_stats$fat))

cor(manual_stats$price, manual_stats$fat)
