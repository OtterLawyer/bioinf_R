
# Сегодня мы обсудим как создавать свои циклы и функции, а также семейство функций apply

# Автор: Алексей Замалутдинов

#-------------------------------------------------------------------------
library(dplyr)
library(ggplot2)
library(tidyr)

#-------------------------------------------------------------------------
# Вкратце напомню как можно выбирать нужные элементы из векторов
d <- c(1,2,3,4,5,3,6,8,1)

# 1) По позиции в векторе (индексу). Нумерация начинается с 1!
d[1]
d[c(1,3)]
d[1:3]

# 2) С помощью логического вектора
e <- d>2
d[e] # или то же самое в одну строчку
d[d>2]

# 3) Указать позиции, которые нужно убрать
d[-4]
d[-(1:3)]

#-------------------------------------------------------------------------
# Тем не менее, наиболее удобный способ хранить данные в R это датафреймы
# Они предстваляют собой набор векторов, и что важно, векторы могут быть типов данных

fruit_and_vegetables_names <- c("cucumber", "banana", "apple", "tomato", "mandarin")
fruit_and_vegetables_price <- c(150, 70, 80, 200, 99)
fruit_and_vegetables_weight <- c(0.4,0.3,0.25,0.2,0.1)

fruit_df <- data.frame(fruit=fruit_and_vegetables_names, price=fruit_and_vegetables_price, weight=fruit_and_vegetables_weight)
fruit_df
str(fruit_df)

# Можно выбирать значения в формате [номер строчки, номер колонки]
fruit_df[3,1]
fruit_df[,1]
# Ещё можно использовать имена колонок, чтобы выбрать одну из них
fruit_df$fruit
View(fruit_df)

#-------------------------------------------------------------------------

# Иногда нам нужно прописать алгоритмы для обработки данных Sometimes we need to build algorithms for data transformations
# и одним из ценных инструментов для этого служат if else выражения
# How it works?

# if (condition) do_1 else do_2
mark <- 3
if (mark >4) print("Excellent!") else print("I should try again")

# Можно сделать более сложные условия с помощью логических операторов &(and) |(or)
price <- 200
amount <- 10
if (price < 250 & amount >= 10) 
  print("Let's buy it") else 
  print("Let's wait for discount")


# Некоторые из операций в R могут применяться к одной величине или вектору целиком 
# На первой паре, что так работают простые операции типа +- и статистические функции 
# То же самое можно делать с if else

f <- c(1,2,3,4)
ifelse(f<2,"Low","High")

# Мы использовали вектор на вход и получили вектор на выходе

# Обратимся к нашему датафрейму
fruit_df
# Добавим новую колонку, где мы скажем дорогой этот фрукт или нет
fruit_df$opinion <- ifelse()
fruit_df

#-------------------------------------------------------------------------

# Иногда нужно повторить какую-то команду несколько раз
# Для этой цели мы можем использовать циклы for 
# Он будет идти по нашей колонке и выполнять какое-то действие 
for (fruit in fruit_df$fruit) {
  print(fruit) 
}
# Здесь он выводит названия фруктов один-за-одним

# Можно также создать вектор специально для интераций по нему
for (i in seq(1:10)) {
  print(i**2)
}

# Можно соединить цикл с if else, для эффективного редактирования
for (i in seq(1:5)) {
  if (fruit_df$opinion[i] == "Expensive") 
    fruit_df$action[i] <- "Ask for discount" else
    fruit_df$action[i] <- "Buy it"
}

fruit_df

#-------------------------------------------------------------------------

# Также мы можем создать цикл через функцию while 
# Цикл будет исполняться, пока условие верно
# Например:

g <- c(1,3,5,7,2,4,5,6,7,8)
i = 1
while (i < 5) {
  print(g[i]**g[i])
  i=i+1
}
i
# Хотя мы могли сделать то же самое в одну строчку :)
g**g

#-------------------------------------------------------------------------

# Мы поработали уже с несколькими функциями и пора обсудить как их создавать

helloworld <- function() {
  print("Hello World!")
}
# При каждом выводе нашей функции она будет писать "Hello World!"
helloworld()
helloworld()

# Созданим чуть более сложную функцию с несколькими аргументами
square_of_rectangle <- function(x,y) {
  square <- x*y
  print(paste("The square of the rectangle is",as.numeric(square)))
}
square_of_rectangle(2,5)

# Тоже самое мы можем задать в виде бинарного оператора 

"%rectangle%" <- function(x,y) {
  square <- x*y
  print(paste("The square of the rectangle is",as.numeric(square)))
}
2 %rectangle% 5

# Встроенный пример такого бинарного опеаратора. Проверяет, есть ли элемент в векторе.
"a" %in% c("e","a","t")

#-------------------------------------------------------------------------
# Мы упоминали, что циклы в R работают не так уж и быстро. Взглянем на работу с большим датасетом
diamonds <- diamonds
str(diamonds)

# У нас есть x,y,z измерения каждого бриллианта. 
# Найдём минимальную из 3 для каждого из них
start.time <- Sys.time()
min_size <- c()
for (i in 1:nrow(diamonds)){
  min_size[i] <-  min(diamonds[i, 8:10])
}
min_size
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken

# Как мы видим цикл не очень быстр, даже на таком среднем датасете
# Но мы можем использовать apply
start.time <- Sys.time()
min_size_2 <- apply(diamonds[, 8:10], 1, min)
min_size_2
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
#-------------------------------------------------------------------------

# Если открыть справку, то в ней написано, что "apply
# returns a vector or array or list of values obtained by 
# applying a function to margins of an array or matrix."

# Как получить array?
apply(diamonds[, 8:10], 2, range)

#-------------------------------------------------------------------------
# Okay, что же такое list?
# Начнём издалека

# Мы можем использлвать в apply не только встроенные функции, но и свои. 
# Давайте напигем функцию, которая возвращает min, mean, max для вектора

min_mean_max <- function(some_vector) {
  c(min(some_vector),mean(some_vector),max(some_vector))
}
min_mean_max(c(1,2,3,4,5,6)) 

# Okay, добавим ещё одну деталь, если min == 0, выводится "Something wrong"

min_mean_max <- function(some_vector) {
  output_vector <- c(min(some_vector, na.rm = T), mean(some_vector, na.rm = T), max(some_vector, na.rm = T))
  ifelse(output_vector[1]==0, return("Something wrong"), return(output_vector))
}

min_mean_max(c(1,2,3,4,5,6,0))  # "Something wrong"
min_mean_max(c(1,2,3,4,5,6)) # 1.0 3.5 6.0

# Значит, мы можем получать разный тип и размер данных в разных случаях
my_list <- apply(diamonds[, c(7:10)], 2, min_mean_max)

# List это коллекция объектов разных размеров и типов
str(my_list)
my_list[[1]]

#-------------------------------------------------------------------------

# Мы более менее разобрались с apply, но это не единственная функция в этом семействе
# Одно из ограничений apply - возможность работы с матрицами и датафреймами
# lapply позволяет применять некоторую функцию к каждому элементу list

my_list <- list(x = rnorm(30), y = rnorm(10))
str(my_list)

lapply(my_list,mean)

# Но может получиться неожиданный результат, если у нас есть пропущенные данные 
my_list <- list(x = c(rnorm(30), NA), y = rnorm(10))
lapply(my_list,mean)

# Чтобы избежать этого, мы можем добавить ещё один аргумент na.rm=T
lapply(my_list,mean, na.rm=T) # Это работает и для apply 

#-------------------------------------------------------------------------

# Вообще говоря, в списке не очень удобно хранить несколько единичных элементов 
# Чтобы сделать удобнее, можно использовать sapply (simplified lapply)
# Она работает как lapply, но по умолчанию пытается упростить формат вывода
sapply(my_list,mean, na.rm=T) # до вектора
sapply(my_list,range, na.rm=T) # до матрицы
# Если неполучается, возвращается list

#-------------------------------------------------------------------------

# На самом деле, датафрейм является особым видом list, и его колонки могут рассматриваться как отдельные элементы
# Таким образом, sapply будет работать
str(diamonds)
sapply(diamonds, is.numeric)

# Разница в работе
# apply должна работать точно также, но из определения мы помним, что она работает с матрицами
# Они должны содержать один тип данных, поэтому колонки конвертируются в chr
apply(diamonds, 2, is.numeric)
#-------------------------------------------------------------------------

